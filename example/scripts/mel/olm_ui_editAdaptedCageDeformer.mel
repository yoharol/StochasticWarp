/*****************************************
**	     global variables
******************************************/
string $cageStr[];
string $objStr[];
string $def;
string $inf;
string $def_out[];

/*****************************************
**	           utilities
******************************************/
// get connected node and attribute
proc string[] getConnection(string $node, string $attr,  int $des, int $src)
{	
	string $results[];
	string $nodes[] = `listConnections -d $des -s $src ($node+"."+$attr)`;
	$results[0] = $nodes[0];
	string $plugs[] = `listConnections -d $des -s $src -p 1 ($node+"."+$attr)`;
	$results[1] = `plugAttr $plugs[0]`;
	return $results;
}

// get connected node
proc string getConnectedNode(string $node, string $attr,  int $des, int $src)
{
	string $result = "";
	string $nodes[] = `listConnections -d $des -s $src ($node+"."+$attr)`;
	if(size($nodes)>0)
		$result = $nodes[0];
	return $result;
}

// get connected node & attribute
proc string[] getConnectedNodeAttr(string $node, string $attr,  int $des, int $src)
{
	string $result[];
	string $nodes[] = `listConnections -p 1 -d $des -s $src ($node+"."+$attr)`;
	if(size($nodes)>0)
	{
		$res = $nodes[0];
		string $buffer[];
		int $num = `tokenize $res "." $result`;
		if($num != 2) error "an error occurs when analysing connected node and attribute";
	}
	return $result;
}

// connect attributes
proc connectAttribute(string $srcNode, string $srcAttr, string $tgtNode, string $tgtAttr)
{
	connectAttr ($srcNode+"."+$srcAttr) ($tgtNode+"."+$tgtAttr);
}

// disconnect attributes
proc disconnectAttribute(string $srcNode, string $srcAttr, string $tgtNode, string $tgtAttr)
{
	disconnectAttr ($srcNode+"."+$srcAttr) ($tgtNode+"."+$tgtAttr);
}

// get next node with an attribute
proc string next(string $node, string $attr)
{
	string $to[] = getConnection($node, $attr, 1, 0);
	return $to[0];
}

// find the influence shape of the given deformer
proc string findInflence(string $deformer)
{
	string $current = $deformer;
	string $next;
	do
	{
		$next = next($current, "outputGeometry");
		$current = $next;
	} while (`nodeType $current`!="transform" );
	return $current;
}

// find an item in a string array
proc int findItem(string $array[], string $item)
{
	return stringArrayFind( $item, 0, $array );
}

// remove an item from a string array
proc int removeItemAt(string $array[], int $index)
{
	if($index >= size($array)) return 0;
	stringArrayRemoveAtIndex($index, $array);
	return 1;
}

// remove
proc removeItem(string $array[], string $item)
{
	string $items[];
	$items[0] = $item;
	stringArrayRemove($items, $array);
}

// append an item to a string array
proc appendItem(string $array[], string $item)
{
	int $index = size($array);
	$array[$index] = $item;
}

// hide an object
proc hideObj(string $obj)
{
	setAttr ($obj+".visibility") 0;
}

// show an object
proc showObj(string $obj)
{
	setAttr ($obj+".visibility") 1;
}

// get parent
proc string getParent(string $node)
{	
	string $ps[] = `listRelatives -fullPath -p $node`;
	return $ps[0];
}

// has any child locator node
proc int hasChild(string $node)
{
	if(`nodeType $node` != "transform") 
		error "given node is not a transform node";
	string $child[] = `listRelatives -f -c $node`;
	for($ch in $child)
	{
		if (`nodeType $ch` == "transform")
			return 1;
	}
	return 0;
}

// return all  child locator nodes
proc string[] children(string $node)
{
	if(`nodeType $node` != "transform") 
		error "given node is not a transform node";
	string $child[] = `listRelatives -f -c $node`;
	string $loc[];
	for($ch in $child)
	{
		if (`nodeType $ch` == "transform")
			appendItem($loc, $ch);
	}
	return $loc;
}

proc string finalNameOf(string $full)
{
	string $buf[];
	int $num = `tokenize $full "|" $buf`;
	return $buf[$num-1];
}

// deactivate a transformation node
proc deactivate(string $node)
{
	if(`nodeType $node` == "transform")
	{
		//setAttr ($node+".visibility") 0;
		setAttr -l true  ($node+".translateX");
		setAttr -l true  ($node+".translateY");
		setAttr -l true  ($node+".translateZ");
		setAttr -l true  ($node+".rotateX");
		setAttr -l true  ($node+".rotateY");
		setAttr -l true  ($node+".rotateZ");
		setAttr -l true  ($node+".scaleX");
		setAttr -l true  ($node+".scaleY");
		setAttr -l true  ($node+".scaleZ");
		setAttr -l true  ($node+".shearXY");
		setAttr -l true  ($node+".shearXZ");
		setAttr -l true  ($node+".shearYZ");
	}
}

proc int active(string $node)
{
	if(`nodeType $node` != "transform") 
		error "given node is not a transform node";
	if( `getAttr -l ($node+".translateX")` == 1) return 0;
	else return 1;
}

// activate a transformation node
proc activate(string $node)
{
	if(`nodeType $node` == "transform")
	{
		//setAttr ($node+".visibility") 1;
		setAttr -l false  ($node+".translateX");
		setAttr -l false  ($node+".translateY");
		setAttr -l false  ($node+".translateZ");
		setAttr -l false  ($node+".rotateX");
		setAttr -l false  ($node+".rotateY");
		setAttr -l false  ($node+".rotateZ");
		setAttr -l false  ($node+".scaleX");
		setAttr -l false  ($node+".scaleY");
		setAttr -l false  ($node+".scaleZ");
		setAttr -l false  ($node+".shearXY");
		setAttr -l false  ($node+".shearXZ");
		setAttr -l false  ($node+".shearYZ");
	}
}

// whether the item exists in a scroll list
proc int itemExists(string $scroll, string $item)
{
	string $all[] = `textScrollList -q -allItems $scroll`;
	if( findItem($all, $item) >= 0 ) return 1;
	else return 0;
}

// create a text locator
proc create_textLocator(string $handleName, string $text, float $r, float $g, float $b, float $x, float $y, float $z)
{
	createNode  transform -n $handleName;
	string $locator = `createNode olmTextHandleLocator -p $handleName`;
	setAttr ($locator+".text") -type "string" $text;
	setAttr ($locator+".color.red") $r;
	setAttr ($locator+".color.green") $g;
	setAttr ($locator+".color.blue") $b;
	setAttr ($handleName+".displayHandle") 1;
	setAttr ($handleName+".translateX") $x;
	setAttr ($handleName+".translateY") $y;
	setAttr ($handleName+".translateZ") $z;
}

// in which text scroll list is a handle
proc string text_scroll(string $node)
{
	if(`nodeType $node` != "transform")
		error "given node is not a transform node";
	string $child[] = `listRelatives -f -c $node`;
	string $loc[];
	for($ch in $child)
	{
		if (`nodeType $ch` == "olmTextHandleLocator")
		{
			string $txt = `getAttr ($ch+".text")`;
			if($txt == "a")
				return "jointListTexts";
			else if($txt == "c")
				return "cageHandleListTexts";
			else if($txt == "o")
				return "objHandleListTexts";
			else
				return "error_list";
		}
	}
	return "error_list";
}

// duplicate a locator
proc string duplicateLocator(string $loc)
{
	string $ds[] = `duplicate $loc`;
	string $d = $ds[0];
	string $ch[] = `listRelatives -fullPath -c $d`;
	for($c in $ch)
	{
		if (`nodeType $c`!="olmTextHandleLocator")
			delete $c;
	}
	if(getParent($d)!="")
	    parent -w $d;
	return $d;
}

// delete all children recursively
proc safe_delete_0(string $hnd)
{
	global string $cageStr[];
	global string $objStr[];
	string $ch[] = children($hnd);
	for($c in $ch)
		safe_delete_0($c);	
	string $fn = finalNameOf($hnd);
	string $text_scroll = text_scroll($fn);
	string $all[] = `textScrollList -q -allItems $text_scroll`;
	int $index = findItem($all, $fn);
	if($index<0) error ($fn+" does not exists in cage handle scroll list");
	if($text_scroll == "cageHandleListTexts")
		removeItemAt($cageStr, $index);
	else if($text_scroll == "objHandleListTexts")
		removeItemAt($objStr, $index);
	else ;
	textScrollList -edit -ri $fn $text_scroll;
	delete $hnd;
}

// safely delete a handle
proc safe_delete(string $hnd)
{	
	if( hasChild($hnd) )
	{
		string $ans = `confirmDialog -title "Warning" -message ($hnd+" has at least one child. Continue?")
			-button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		if($ans == "Yes")
		{
			safe_delete_0($hnd);
		}
	}
	else
	{
		safe_delete_0($hnd);
	}
}

/*****************************************
**	     callback functions
******************************************/
// callback to detaching this deformer
global proc detach_cb()
{
	global string $def_out[];
	global string $def;
	button -edit -enable on removeCageHandleButton;
	button -edit -enable on removeObjHandleButton;
	button -edit -enable on detJointButton;
	button -edit -enable on removeJointButton;
	button -edit -enable off detButton;
	disconnectAttribute($def, "outputGeometry[0]", $def_out[0], $def_out[1]);
}

// callback to creating a new handle
global proc new_handle_cb()
{
	global string $cageStr[];
	global string $objStr[];
	string $result = `promptDialog -title "Rename Object" -message "Enter Name:" -button "OK" -button "Cancel"
		-defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
	if ($result == "OK") 
	{		
		string $sel[] = `ls -sl`;
		string $cage = `textField -q -text cageTextField`;
		string $obj = `textField -q -text objectTextField`;
		string $buffer[];
		tokenize $sel[0] "." $buffer;
		string $sel_obj = $buffer[0];
		int $isCage;
		if($sel_obj == $cage) $isCage = 1;
		else if($sel_obj == $obj) $isCage = 0;
		else error "selected vertices from a wrong mesh?";
		float $bbox[] = `exactWorldBoundingBox`;	
		float $x =  ($bbox[0]+ $bbox[3])/2;
		float $y =  ($bbox[1]+ $bbox[4])/2;
		float $z =  ($bbox[2]+ $bbox[5])/2;
		string $handleName;
		$text = `promptDialog -query -text`;
		if($isCage==1)
		{
			int $hndCount = size($cageStr);
			int $itmCount = `textScrollList -q -ni cageHandleListTexts`;
			if($hndCount != $itmCount)
			{
				error "an error occurs when adding a new cage constraint";
				return;
			}
			$cageStr[$hndCount] = stringArrayToString($sel," ");
			if($text == "") $handleName = ("cageHandle"+$hndCount);
			else $handleName = $text;
			create_textLocator($handleName, "c", 1.0, 0.0, 0.0, $x, $y, $z);
			textScrollList -edit -append $handleName cageHandleListTexts;
		}		
		else
		{
			int $hndCount = size($objStr);
			int $itmCount = `textScrollList -q -ni objHandleListTexts`;
			if($hndCount != $itmCount)
			{
				error "an error occurs when adding a new object constraint";
				return;
			}
			$objStr[$hndCount] = stringArrayToString($sel," ");
			if($text == "") $handleName = ("objectHandle"+$hndCount);
			else $handleName = $text;
			create_textLocator($handleName, "o", 0.0, 1.0, 0.0, $x, $y, $z);
			textScrollList -edit -append $handleName objHandleListTexts;	
		}
	}	
}

// callback to detaching a joint from the deformer
global proc activate_cb()
{
	string $sel_items[] = `textScrollList -q -selectItem jointListTexts`;
	string $sel_item = $sel_items[0];
	if( hasChild($sel_item) )
	{
		string $ans = `confirmDialog -title "Warning" -message ($sel_item+" has at least one child. unparent first?")
			-button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		if($ans == "Yes")
		{
			string $ch[] = children($sel_item);			
			for($c in $ch)
			{
				string $last_name = finalNameOf($c);
				activate($c);
				parent -w $c;
				//deactivate($last_name);
			}
		}
		else return;
	}
	string $hnd_out[] = getConnectedNodeAttr($sel_item, "worldMatrix",1,0);
	if(size($hnd_out)==2)
	{
		//disconnectAttribute($sel_item, "worldMatrix", $hnd_out[0], $hnd_out[1]);
		activate($sel_item);
	}
}

// callback to removing an existing handle
global proc del_handle_cb(string $type)
{
	if($type == "cage")
	{
		string $sel_items[] = `textScrollList -q -selectItem cageHandleListTexts`;
		string $item = $sel_items[0];
		safe_delete($item);
	}
	else // $type == "object"
	{
		string $sel_items[] = `textScrollList -q -selectItem objHandleListTexts`;
		string $item = $sel_items[0];
		safe_delete($item);
	}		
}

// callback to creating a new anchor
global proc new_joint_cb()
{
	// create a new joint
	string $result = `promptDialog -title "Rename anchor" -message "Enter Name:" 
		-button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" 
		-dismissString "Cancel"`;	
	if ($result == "OK") 
	{
		string $anchor_name = `promptDialog -query -text`;
		if( $anchor_name == "")
		{
			int $num_item =`textScrollList -q -numberOfItems jointListTexts`;
			$anchor_name = "anchor"+$num_item;
		}
		create_textLocator($anchor_name, "a", 0.0, 0.0, 1.0, 0, 0, 0);		
		textScrollList -edit -append $anchor_name jointListTexts;
	}
}

// callback to removing an anchor handle
global proc del_joint_cb()
{
	string $sel_items[] = `textScrollList -q -selectItem jointListTexts`;
	string $sel_item = $sel_items[0];
	safe_delete($sel_item);
}

// callback to selecting a handle
global proc sel_handle_cb(string $hnd)
{
	string $sel;
	if($hnd == "cage")
	{
		string $sel_hnd[] = `textScrollList -q -selectItem cageHandleListTexts`;
		$sel = $sel_hnd[0];
		textScrollList -e -deselectAll objHandleListTexts;
	}
	else
	{
		string $sel_hnd[] = `textScrollList -q -selectItem objHandleListTexts`;
		$sel = $sel_hnd[0];
		textScrollList -e -deselectAll cageHandleListTexts;
	}
	select $sel;
}

// callback to selecting an anchor
global proc sel_joint_cb()
{
	string $sels[] = `textScrollList -q -selectItem jointListTexts`;
	string $sel = $sels[0];
	select $sel;
}

// perform editing
global proc do_edit()
{
	// global variables
	global string $cageStr[];
	global string $objStr[];
	global string $def_out[];
	global string $def;
	global string $inf;
	
	// get current connections and parameters
	int $iter = `getAttr ($def+".arapIterations")`;
	setAttr ($def+".arapIterations") 500;
	
	// disconnect existing handles
	string $cu_cage_hnds[] = `textScrollList -q -allItems cageHandleListTexts`;
	for($cg in $cu_cage_hnds)
	{
		string $cg_out[] = getConnectedNodeAttr($cg, "worldMatrix",1,0);
		activate($cg);
		if( size($cg_out) == 2)
			disconnectAttribute($cg, "worldMatrix", $cg_out[0], $cg_out[1]);
	}
	string $cu_obj_hnds[] = `textScrollList -q -allItems objHandleListTexts`;
	for($ob in $cu_obj_hnds)
	{
		string $ob_out[] = getConnectedNodeAttr($ob, "worldMatrix",1,0);
		activate($ob);
		if( size($ob_out) == 2)
			disconnectAttribute($ob, "worldMatrix", $ob_out[0], $ob_out[1]);
	}
	string $cu_anch_hnds[] = `textScrollList -q -allItems jointListTexts`;
	for($an in $cu_anch_hnds)
	{
		string $an_out[] = getConnectedNodeAttr($an, "worldMatrix",1,0);
		activate($an);
		if( size($an_out) == 2)
			disconnectAttribute($an, "worldMatrix", $an_out[0], $an_out[1]);
	}
	
	// clear all existing constraints
	int $cageHndCount = `getAttr -s ($def+".cageHandleMatrix")`;
	int $i;
	for($i=0; $i<$cageHndCount; $i++)
	{
		string $plug = "cageHandleMatrix[" + $i +"]";
		string $orgPlug = "orgCgHndMatrix[" + $i +"]";		
		removeMultiInstance -b true ($def+"."+$plug);
		removeMultiInstance -b true ($def+"."+$orgPlug);
		removeMultiInstance ($def+".cageHandleString["+$i+"]");
	}
	int $objHndCount = `getAttr -s ($def+".objHandleMatrix")`;
	for($i=0; $i<$objHndCount; $i++)
	{
		string $plug = "objHandleMatrix[" + $i +"]";
		string $orgPlug = "orgObjHndMatrix[" + $i +"]";
		removeMultiInstance -b true ($def+"."+$plug);
		removeMultiInstance -b true ($def+"."+$orgPlug);
		removeMultiInstance ($def+".objHandleString["+$i+"]");
	}
	int $jtHndCount = `getAttr -s ($def+".joints")`;
	for($i=0; $i<$jtHndCount; $i++)
	{
		string $plug = "joints[" + $i +"]";
		string $orgPlug = "orgAnchMatrix[" + $i +"]";
		removeMultiInstance -b true ($def+"."+$plug);
		removeMultiInstance -b true ($def+"."+$orgPlug);
	}
	string $orgCons = "orgConstraints";
	if(`objExists $orgCons`) delete $orgCons;
	

	// set new constraints
	// cage constraints (strings and handles)
	string $orgs[];
	if(size($cu_cage_hnds)!=size($cageStr))
		error "an error occurs to get cage handles.\n";
	int $i=0;
	for($i=0; $i<size($cu_cage_hnds); $i++)
	{
		string $hnd = $cu_cage_hnds[$i];
		getAttr -type ($def+".cageHandleString["+$i+"]");
		getAttr -type ($def+".cageHandleMatrix["+$i+"]");
		setAttr ($def+".cageHandleString["+$i+"]") -type "string" $cageStr[$i];
		connectAttribute($hnd, "worldMatrix", $def, "cageHandleMatrix["+$i+"]");
		// add an locked original handle
		string $orgHnd = duplicateLocator($hnd);
		select $orgHnd;
		$orgHnd = $hnd+"Org";
		rename $orgHnd;
		deactivate($orgHnd);
		getAttr -type ($def+".orgCgHndMatrix["+$i+"]");
		connectAttribute($orgHnd, "worldMatrix", $def, "orgCgHndMatrix["+$i+"]");
		$orgs[size($orgs)] = $orgHnd;
	}
	
	// object constraints (strings and handles)
	if(size($cu_obj_hnds)!=size($objStr))
		error "an error occurs to get object handles.\n";
	for($i=0; $i<size($cu_obj_hnds); $i++)
	{
		string $hnd = $cu_obj_hnds[$i];
		getAttr -type ($def+".objHandleString["+$i+"]");
		getAttr -type ($def+".objHandleMatrix["+$i+"]");
		setAttr ($def+".objHandleString["+$i+"]") -type "string" $objStr[$i];
		connectAttribute($hnd, "worldMatrix", $def, "objHandleMatrix["+$i+"]");
		// add an locked original handle
		string $orgHnd = duplicateLocator($hnd);
		select $orgHnd;
		$orgHnd = $hnd+"Org";
		rename ($hnd+"Org");
		deactivate($orgHnd);
		getAttr -type ($def+".orgObjHndMatrix["+$i+"]");
		connectAttribute($orgHnd, "worldMatrix", $def, "orgObjHndMatrix["+$i+"]");
		$orgs[size($orgs)] = $orgHnd;
	}
	
	// anchor constraints (locators)
	int $num_joint = size($cu_anch_hnds);
	for($i=0; $i<$num_joint; $i++)
	{
		string $jt = $cu_anch_hnds[$i];
		getAttr -type ($def+".joints["+$i+"]");
		connectAttribute($jt, "worldMatrix", $def, "joints["+$i+"]");
		string $orgJt = duplicateLocator($jt);
		select $orgJt;
		$orgJt = $jt+"Org";
		rename $orgJt;
		deactivate($orgJt);
		getAttr -type ($def+".orgAnchMatrix["+$i+"]");
		connectAttribute($orgJt, "worldMatrix", $def, "orgAnchMatrix["+$i+"]");
		$orgs[size($orgs)] = $orgJt;
	}
	select -r $orgs;
	group -n  $orgCons;
	hideObj( $orgCons );
	
	// re-connect the output
	connectAttribute($def, "outputGeometry[0]", $def_out[0], $def_out[1]);
	setAttr ($def+".arapIterations") $iter;

	deleteUI editCageTransformWindow;	
}

global proc cancel_cb()
{
	global string $def;
	global string $def_out[];
	connectAttribute($def, "outputGeometry[0]", $def_out[0], $def_out[1]);
	deleteUI editCageTransformWindow;
}
/*****************************************
**	               UI
******************************************/
// create UI
proc create_ui()
{
	// define UI elements
	if(`window -exists editCageTransformWindow`==1)
		deleteUI editCageTransformWindow;
	window -resizeToFitChildren 1 -title "Edit Adapted Cage Deformer" editCageTransformWindow;
	columnLayout;
		frameLayout -label "Object and Cage" -width 400 -borderStyle "out";
			columnLayout;
				rowLayout -numberOfColumns 2;					
					text -label "Object" -width 195 -align "left";	
					text -label "Cage" -width 195 -align "left";					
				setParent ..;
				rowLayout -numberOfColumns 2;	
					textField -width 195 objectTextField;
					textField -width 195 cageTextField;										
				setParent ..;
			setParent;
		setParent;
		frameLayout -label "Edit Constraints" -borderStyle "out" -width 400; 
			columnLayout;	
				button -label "Detach" -width 100 -enable on -command "detach_cb" detButton;
				rowLayout -numberOfColumns 2;
					text -label "Cage Constraints" -width 195 -align "left";
					text -label "Object Constraints" -width 195 -align "left";
				setParent ..;
				rowLayout -numberOfColumns 2;
					textScrollList -numberOfRows 12 -allowMultiSelection off -width 195 -height 150 
						-selectCommand "sel_handle_cb cage" cageHandleListTexts;
					textScrollList -numberOfRows 12 -allowMultiSelection off -width 195 -height 150 
						-selectCommand "sel_handle_cb object" objHandleListTexts;
				setParent..;
				rowLayout -numberOfColumns 4;
					button -label "New" -width 96 -command "new_handle_cb" addCageHandleButton;
					button -label "Delete" -width 96 -enable off -command "del_handle_cb cage" removeCageHandleButton; 
					button -label "New" -width 96 -command "new_handle_cb" addObjHandleButton;
					button -label "Delete" -width 96 -enable off -command "del_handle_cb object" removeObjHandleButton; 
				setParent..;
			setParent..;
		setParent..;
		text -label "Anchor Constraints" -width 195 -align "left";
		columnLayout;
			text -label "Joints" -width 195 -align "left";
			textScrollList -numberOfRows 12 -allowMultiSelection off -width 395 -height 100 
				-selectCommand "sel_joint_cb" jointListTexts;
			checkBox -label "open" openCheckButton;
			rowLayout -numberOfColumns 3;
				button -label "New" -width 80 -command "new_joint_cb" addJointButton;
				button -label "Activate" -width 80 -enable off -command "activate_cb" detJointButton;
				button -label "Delete" -width 80 -enable off -command "del_joint_cb" removeJointButton; 
			setParent..;
		setParent..;		
		frameLayout -label "Confirm" -borderStyle "out" -width 400; 
			rowLayout -numberOfColumns 2;
				button -label "OK" -width 80 -command "do_edit";
				button -label "Cancel" -width 80 -command "cancel_cb";
			setParent ..;		
		setParent ..;		
	setParent ..;	
	showWindow;
}

// edit UI
proc edit_ui(string $obj, string $cage, int $open, string $cgHnds[], string $obHnds[], string $jtHnds[])
{
	textField -edit -text $obj -enable off objectTextField;
	textField -edit -text $cage -enable off cageTextField;	
	checkBox -edit -value $open -enable off openCheckButton;
	
	for($ch in $cgHnds)
		textScrollList -edit -append $ch cageHandleListTexts;
	for($oh in $obHnds)
		textScrollList -edit -append $oh objHandleListTexts;
	for($jh in $jtHnds)
		textScrollList -edit -append $jh jointListTexts;
}

// global function called by users for editing
global proc olm_ui_editAdaptedCageDeformer()
{
	// clear global variables
	global string $cageStr[];
	global string $objStr[];
	global string $def_out[];
	global string $def;
	global string $inf;
	clear $cageStr;
	clear $objStr;
	clear $def_out;
	string $sl[] = `ls -sl`;
	if(size($sl)<1)
		error "Please select the cage mesh connecting with the deformer you want to edit";
	string $cg = $sl[0];
	$def = getConnectedNode($sl[0], "inMesh", 0, 1);
	string $type = `nodeType $def`;
	if($type != "olmAutoCageTransform")
		error "The selected mesh is not connected with an adapted cage deformer";
	$inf = findInflence($def);
	string $def_out[] = getConnectedNodeAttr($def, "outputGeometry[0]",1,0);
	if( size($def_out) ==0 ) error "failed to get downstream of olmAutoCageTransform deformer";
	
	int $open = `getAttr ($def+ ".close")`;
	int $cg_size = `getAttr -size ($def+ ".cageHandleMatrix")`;
	int $i;
	string $cgHnds[];
	for($i=0; $i<$cg_size; $i++)
	{
		string $in = "cageHandleMatrix["+$i+"]";
		$cgHnds[$i] = getConnectedNode($def, $in, 0, 1);
		deactivate($cgHnds[$i]);
		$cageStr[$i] = `getAttr ($def+".cageHandleString["+$i+"]")`;
	}
	int $ob_size = `getAttr -size ($def+ ".objHandleMatrix")`;
	string $objHnds[];
	for($i=0; $i<$ob_size; $i++)
	{
		string $in = "objHandleMatrix["+$i+"]";
		$objHnds[$i] = getConnectedNode($def, $in, 0, 1);
		deactivate($objHnds[$i]);
		$objStr[$i] = `getAttr ($def+".objHandleString["+$i+"]")`;
	}
	int $an_size = `getAttr -size ($def+ ".joints")`;
	string $jtHnds[];
	for($i=0; $i<$an_size; $i++)
	{
		string $in = "joints["+$i+"]";
		$jtHnds[$i] = getConnectedNode($def, $in, 0, 1);
		deactivate($jtHnds[$i]);
	}
	create_ui();
	edit_ui($inf, $cg, $open, $cgHnds, $objHnds, $jtHnds);
}
olm_ui_editAdaptedCageDeformer();